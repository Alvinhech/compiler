0	CONSTsym	const
1	CHARsym	char
2	IDENT	lll
3	BECOMES	=
4	CHAR	a
5	SEMICOLON	;
6	INTsym	int
7	IDENT	glob1
8	SEMICOLON	;
9	CHARsym	char
10	IDENT	glob2
11	Lbra	[
12	NUMBER	100
13	Rbra	]
14	SEMICOLON	;
15	VOIDsym	void
16	IDENT	mod
17	Lpar	(
18	INTsym	int
19	IDENT	a
20	COMMA	,
21	CHARsym	char
22	IDENT	b
23	Rpar	)
24	Lbrc	{
25	INTsym	int
26	IDENT	temp
27	IFsym	if
28	Lpar	(
29	IDENT	a
30	LESS	<
31	IDENT	b
32	Rpar	)
33	Lbrc	{
34	IDENT	temp
35	BECOMES	=
36	IDENT	a
37	SEMICOLON	;
38	IDENT	a
39	BECOMES	=
40	IDENT	b
41	SEMICOLON	;
42	IDENT	b
43	BECOMES	=
44	IDENT	temp
45	Rbrc	}
46	FORsym	for
47	Lpar	(
48	IDENT	i
49	BECOMES	=
50	NUMBER	1
51	SEMICOLON	;
52	IDENT	i
53	LESS	<
54	IDENT	a
55	SEMICOLON	;
56	IDENT	i
57	BECOMES	=
58	IDENT	i
59	PLUS	+
60	NUMBER	1
61	Rpar	)
62	Lbrc	{
63	IFsym	if
64	Lpar	(
65	IDENT	a
66	EQL	==
67	IDENT	i
68	MUL	*
69	IDENT	b
70	Rpar	)
71	RETURNsym	return
72	Lpar	(
73	NUMBER	1
74	Rpar	)
75	SEMICOLON	;
76	Rbrc	}
77	RETURNsym	return
78	Lpar	(
79	ZERO	0
80	Rpar	)
81	SEMICOLON	;
82	Rbrc	}
83	INTsym	int
84	IDENT	max_yz
85	Lpar	(
86	INTsym	int
87	IDENT	a
88	COMMA	,
89	INTsym	int
90	IDENT	b
91	Rpar	)
92	Lbrc	{
93	IFsym	if
94	Lpar	(
95	IDENT	mod
96	Lpar	(
97	IDENT	a
98	COMMA	,
99	IDENT	b
100	Rpar	)
101	Rpar	)
102	Lbrc	{
103	IFsym	if
104	Lpar	(
105	IDENT	a
106	GT	>
107	IDENT	b
108	Rpar	)
109	RETURNsym	return
110	Lpar	(
111	IDENT	b
112	Rpar	)
113	SEMICOLON	;
114	ELSEsym	else
115	RETURNsym	return
116	Lpar	(
117	IDENT	a
118	Rpar	)
119	SEMICOLON	;
120	Rbrc	}
121	IFsym	if
122	Lpar	(
123	IDENT	a
124	GT	>
125	IDENT	b
126	Rpar	)
127	IDENT	ret
128	BECOMES	=
129	IDENT	max_yz
130	Lpar	(
131	IDENT	b
132	COMMA	,
133	IDENT	a
134	MINUS	-
135	IDENT	b
136	Rpar	)
137	SEMICOLON	;
138	ELSEsym	else
139	IDENT	ret
140	BECOMES	=
141	IDENT	max_yz
142	Lpar	(
143	IDENT	a
144	COMMA	,
145	IDENT	b
146	MINUS	-
147	IDENT	a
148	Rpar	)
149	SEMICOLON	;
150	RETURNsym	return
151	Lpar	(
152	IDENT	ret
153	Rpar	)
154	SEMICOLON	;
155	Rbrc	}
156	VOIDsym	void
157	MAINsym	main
158	Lpar	(
159	Rpar	)
160	Lbrc	{
161	CONSTsym	const
162	INTsym	int
163	IDENT	cst
164	BECOMES	=
165	NUMBER	1
166	SEMICOLON	;
167	INTsym	int
168	IDENT	a
169	COMMA	,
170	IDENT	b
171	COMMA	,
172	IDENT	c
173	COMMA	,
174	IDENT	counter
175	COMMA	,
176	IDENT	i
177	COMMA	,
178	IDENT	array
179	Lbra	[
180	NUMBER	3
181	Rbra	]
182	SEMICOLON	;
183	INTsym	int
184	IDENT	a
185	SEMICOLON	;
186	CHARsym	char
187	IDENT	c
188	SEMICOLON	;
189	INTsym	int
190	IDENT	AuAs
191	SEMICOLON	;
192	CHARsym	char
193	IDENT	dfQS
194	SEMICOLON	;
195	IDENT	AuAs
196	BECOMES	=
197	IDENT	a
198	PLUS	+
199	IDENT	a
200	SEMICOLON	;
201	IDENT	array
202	Lbra	[
203	NUMBER	2
204	Rbra	]
205	BECOMES	=
206	IDENT	a
207	SEMICOLON	;
208	FORsym	for
209	Lpar	(
210	IDENT	glob1
211	BECOMES	=
212	ZERO	0
213	SEMICOLON	;
214	IDENT	glob1
215	LESS	<
216	IDENT	cst
217	SEMICOLON	;
218	IDENT	glob1
219	BECOMES	=
220	IDENT	glob1
221	PLUS	+
222	NUMBER	1
223	Rpar	)
224	Lbrc	{
225	PRINTFsym	printf
226	Lpar	(
227	STRING	please enter two numbers
228	Rpar	)
229	SEMICOLON	;
230	SCANFsym	scanf
231	Lpar	(
232	IDENT	a
233	COMMA	,
234	IDENT	b
235	Rpar	)
236	SEMICOLON	;
237	IDENT	result
238	BECOMES	=
239	IDENT	max_yz
240	Lpar	(
241	IDENT	a
242	COMMA	,
243	IDENT	b
244	Rpar	)
245	SEMICOLON	;
246	PRINTFsym	printf
247	Lpar	(
248	STRING	common factor is: 
249	COMMA	,
250	IDENT	result
251	Rpar	)
252	SEMICOLON	;
253	Rbrc	}
254	DOsym	do
255	Lbrc	{
256	PRINTFsym	printf
257	Lpar	(
258	STRING	enter a number lower than 10
259	Rpar	)
260	SEMICOLON	;
261	SCANFsym	scanf
262	Lpar	(
263	IDENT	c
264	Rpar	)
265	SEMICOLON	;
266	IFsym	if
267	Lpar	(
268	IDENT	c
269	GT	>
270	NUMBER	10
271	Rpar	)
272	PRINTFsym	printf
273	Lpar	(
274	STRING	sth wrong,number>10
275	Rpar	)
276	SEMICOLON	;
277	ELSEsym	else
278	SEMICOLON	;
279	Rbrc	}
280	WHILEsym	while
281	Lpar	(
282	IDENT	c
283	GT	>
284	NUMBER	10
285	Rpar	)
286	IDENT	counter
287	BECOMES	=
288	NUMBER	10
289	SEMICOLON	;
290	DOsym	do
291	Lbrc	{
292	IDENT	counter
293	BECOMES	=
294	IDENT	counter
295	MINUS	-
296	NUMBER	1
297	SEMICOLON	;
298	PRINTFsym	printf
299	Lpar	(
300	STRING	enter do-while at times: 
301	COMMA	,
302	IDENT	counter
303	Rpar	)
304	SEMICOLON	;
305	Rbrc	}
306	WHILEsym	while
307	Lpar	(
308	IDENT	max_yz
309	Lpar	(
310	IDENT	counter
311	COMMA	,
312	IDENT	c
313	Rpar	)
314	NEQ	!=
315	ZERO	0
316	Rpar	)
317	PRINTFsym	printf
318	Lpar	(
319	STRING	enter low and high index of array
320	Rpar	)
321	SEMICOLON	;
322	FORsym	for
323	Lpar	(
324	IDENT	i
325	BECOMES	=
326	ZERO	0
327	SEMICOLON	;
328	IDENT	i
329	LESS	<
330	NUMBER	100
331	SEMICOLON	;
332	IDENT	i
333	BECOMES	=
334	IDENT	i
335	PLUS	+
336	NUMBER	1
337	Rpar	)
338	Lbrc	{
339	IDENT	array
340	Lbra	[
341	IDENT	i
342	Rbra	]
343	BECOMES	=
344	IDENT	i
345	MUL	*
346	IDENT	i
347	SEMICOLON	;
348	Rbrc	}
349	SCANFsym	scanf
350	Lpar	(
351	IDENT	a
352	COMMA	,
353	IDENT	b
354	Rpar	)
355	SEMICOLON	;
356	FORsym	for
357	Lpar	(
358	IDENT	i
359	BECOMES	=
360	IDENT	a
361	SEMICOLON	;
362	IDENT	i
363	LESS	<
364	IDENT	b
365	SEMICOLON	;
366	IDENT	i
367	BECOMES	=
368	IDENT	i
369	PLUS	+
370	NUMBER	1
371	Rpar	)
372	Lbrc	{
373	PRINTFsym	printf
374	Lpar	(
375	IDENT	i
376	Rpar	)
377	SEMICOLON	;
378	Rbrc	}
379	RETURNsym	return
380	SEMICOLON	;
381	Rbrc	}
382	EOF	
