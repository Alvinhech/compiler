0	CONSTsym	const
1	CHARsym	char
2	IDENT	lll
3	BECOMES	=
4	CHAR	a
5	SEMICOLON	;
6	INTsym	int
7	IDENT	glob1
8	SEMICOLON	;
9	CHARsym	char
10	IDENT	glob2
11	Lbra	[
12	NUMBER	100
13	Rbra	]
14	SEMICOLON	;
15	VOIDsym	void
16	IDENT	mod
17	Lpar	(
18	INTsym	int
19	IDENT	a
20	COMMA	,
21	CHARsym	char
22	IDENT	b
23	Rpar	)
24	Lbrc	{
25	INTsym	int
26	IDENT	temp
27	SEMICOLON	;
28	IFsym	if
29	Lpar	(
30	IDENT	a
31	LESS	<
32	IDENT	b
33	Rpar	)
34	Lbrc	{
35	IDENT	temp
36	BECOMES	=
37	IDENT	a
38	SEMICOLON	;
39	IDENT	a
40	BECOMES	=
41	IDENT	b
42	SEMICOLON	;
43	IDENT	b
44	BECOMES	=
45	IDENT	temp
46	SEMICOLON	;
47	Rbrc	}
48	FORsym	for
49	Lpar	(
50	IDENT	i
51	BECOMES	=
52	NUMBER	1
53	SEMICOLON	;
54	IDENT	i
55	LESS	<
56	IDENT	a
57	SEMICOLON	;
58	IDENT	i
59	BECOMES	=
60	IDENT	i
61	PLUS	+
62	NUMBER	1
63	Rpar	)
64	Lbrc	{
65	IFsym	if
66	Lpar	(
67	IDENT	a
68	EQL	==
69	IDENT	i
70	MUL	*
71	IDENT	b
72	Rpar	)
73	RETURNsym	return
74	Lpar	(
75	NUMBER	1
76	Rpar	)
77	SEMICOLON	;
78	Rbrc	}
79	RETURNsym	return
80	Lpar	(
81	ZERO	0
82	Rpar	)
83	SEMICOLON	;
84	Rbrc	}
85	INTsym	int
86	IDENT	max_yz
87	Lpar	(
88	INTsym	int
89	IDENT	a
90	COMMA	,
91	INTsym	int
92	IDENT	b
93	Rpar	)
94	Lbrc	{
95	IFsym	if
96	Lpar	(
97	IDENT	mod
98	Lpar	(
99	IDENT	a
100	COMMA	,
101	IDENT	b
102	Rpar	)
103	Rpar	)
104	Lbrc	{
105	IFsym	if
106	Lpar	(
107	IDENT	a
108	GT	>
109	IDENT	b
110	Rpar	)
111	RETURNsym	return
112	Lpar	(
113	IDENT	b
114	Rpar	)
115	SEMICOLON	;
116	ELSEsym	else
117	RETURNsym	return
118	Lpar	(
119	IDENT	a
120	Rpar	)
121	SEMICOLON	;
122	Rbrc	}
123	IFsym	if
124	Lpar	(
125	IDENT	a
126	GT	>
127	IDENT	b
128	Rpar	)
129	IDENT	ret
130	BECOMES	=
131	IDENT	max_yz
132	Lpar	(
133	IDENT	b
134	COMMA	,
135	IDENT	a
136	MINUS	-
137	IDENT	b
138	Rpar	)
139	SEMICOLON	;
140	ELSEsym	else
141	IDENT	ret
142	BECOMES	=
143	IDENT	max_yz
144	Lpar	(
145	IDENT	a
146	COMMA	,
147	IDENT	b
148	MINUS	-
149	IDENT	a
150	Rpar	)
151	SEMICOLON	;
152	RETURNsym	return
153	Lpar	(
154	IDENT	ret
155	Rpar	)
156	SEMICOLON	;
157	Rbrc	}
158	VOIDsym	void
159	MAINsym	main
160	Lpar	(
161	Rpar	)
162	Lbrc	{
163	CONSTsym	const
164	INTsym	int
165	IDENT	cst
166	BECOMES	=
167	NUMBER	1
168	SEMICOLON	;
169	INTsym	int
170	IDENT	a
171	COMMA	,
172	IDENT	b
173	COMMA	,
174	IDENT	c
175	COMMA	,
176	IDENT	counter
177	COMMA	,
178	IDENT	i
179	COMMA	,
180	IDENT	array
181	Lbra	[
182	NUMBER	3
183	Rbra	]
184	SEMICOLON	;
185	INTsym	int
186	IDENT	a
187	SEMICOLON	;
188	CHARsym	char
189	IDENT	c
190	SEMICOLON	;
191	INTsym	int
192	IDENT	AuAs
193	SEMICOLON	;
194	CHARsym	char
195	IDENT	dfQS
196	SEMICOLON	;
197	IDENT	AuAs
198	BECOMES	=
199	IDENT	a
200	PLUS	+
201	IDENT	a
202	SEMICOLON	;
203	IDENT	array
204	Lbra	[
205	NUMBER	2
206	Rbra	]
207	BECOMES	=
208	IDENT	a
209	SEMICOLON	;
210	FORsym	for
211	Lpar	(
212	IDENT	glob1
213	BECOMES	=
214	ZERO	0
215	SEMICOLON	;
216	IDENT	glob1
217	LESS	<
218	IDENT	cst
219	SEMICOLON	;
220	IDENT	glob1
221	BECOMES	=
222	IDENT	glob1
223	PLUS	+
224	NUMBER	1
225	Rpar	)
226	Lbrc	{
227	PRINTFsym	printf
228	Lpar	(
229	STRING	please enter two numbers
230	Rpar	)
231	SEMICOLON	;
232	SCANFsym	scanf
233	Lpar	(
234	IDENT	a
235	COMMA	,
236	IDENT	b
237	Rpar	)
238	SEMICOLON	;
239	IDENT	result
240	BECOMES	=
241	IDENT	max_yz
242	Lpar	(
243	IDENT	a
244	COMMA	,
245	IDENT	b
246	Rpar	)
247	SEMICOLON	;
248	PRINTFsym	printf
249	Lpar	(
250	STRING	common factor is: 
251	COMMA	,
252	IDENT	result
253	Rpar	)
254	SEMICOLON	;
255	Rbrc	}
256	DOsym	do
257	Lbrc	{
258	PRINTFsym	printf
259	Lpar	(
260	STRING	enter a number lower than 10
261	Rpar	)
262	SEMICOLON	;
263	SCANFsym	scanf
264	Lpar	(
265	IDENT	c
266	Rpar	)
267	SEMICOLON	;
268	IFsym	if
269	Lpar	(
270	IDENT	c
271	GT	>
272	NUMBER	10
273	Rpar	)
274	PRINTFsym	printf
275	Lpar	(
276	STRING	sth wrong,number>10
277	Rpar	)
278	SEMICOLON	;
279	ELSEsym	else
280	SEMICOLON	;
281	Rbrc	}
282	WHILEsym	while
283	Lpar	(
284	IDENT	c
285	GT	>
286	NUMBER	10
287	Rpar	)
288	IDENT	counter
289	BECOMES	=
290	NUMBER	10
291	SEMICOLON	;
292	DOsym	do
293	Lbrc	{
294	IDENT	counter
295	BECOMES	=
296	IDENT	counter
297	MINUS	-
298	NUMBER	1
299	SEMICOLON	;
300	PRINTFsym	printf
301	Lpar	(
302	STRING	enter do-while at times: 
303	COMMA	,
304	IDENT	counter
305	Rpar	)
306	SEMICOLON	;
307	Rbrc	}
308	WHILEsym	while
309	Lpar	(
310	IDENT	max_yz
311	Lpar	(
312	IDENT	counter
313	COMMA	,
314	IDENT	c
315	Rpar	)
316	NEQ	!=
317	ZERO	0
318	Rpar	)
319	PRINTFsym	printf
320	Lpar	(
321	STRING	enter low and high index of array
322	Rpar	)
323	SEMICOLON	;
324	FORsym	for
325	Lpar	(
326	IDENT	i
327	BECOMES	=
328	ZERO	0
329	SEMICOLON	;
330	IDENT	i
331	LESS	<
332	NUMBER	100
333	SEMICOLON	;
334	IDENT	i
335	BECOMES	=
336	IDENT	i
337	PLUS	+
338	NUMBER	1
339	Rpar	)
340	Lbrc	{
341	IDENT	array
342	Lbra	[
343	IDENT	i
344	Rbra	]
345	BECOMES	=
346	IDENT	i
347	MUL	*
348	IDENT	i
349	SEMICOLON	;
350	Rbrc	}
351	SCANFsym	scanf
352	Lpar	(
353	IDENT	a
354	COMMA	,
355	IDENT	b
356	Rpar	)
357	SEMICOLON	;
358	FORsym	for
359	Lpar	(
360	IDENT	i
361	BECOMES	=
362	IDENT	a
363	SEMICOLON	;
364	IDENT	i
365	LESS	<
366	IDENT	b
367	SEMICOLON	;
368	IDENT	i
369	BECOMES	=
370	IDENT	i
371	PLUS	+
372	NUMBER	1
373	Rpar	)
374	Lbrc	{
375	PRINTFsym	printf
376	Lpar	(
377	IDENT	i
378	Rpar	)
379	SEMICOLON	;
380	Rbrc	}
381	RETURNsym	return
382	SEMICOLON	;
383	Rbrc	}
384	EOF	
